$date
	Fri Dec 10 11:39:36 2021
$end
$version
	Icarus Verilog
$end
$timescale
	1s
$end
$scope module mips_cpu_bus_tb $end
$var wire 32 ! writedata [31:0] $end
$var wire 1 " write $end
$var wire 32 # register_v0 [31:0] $end
$var wire 1 $ read $end
$var wire 4 % byteenable [3:0] $end
$var wire 32 & address [31:0] $end
$var wire 1 ' active $end
$var reg 1 ( clk $end
$var reg 32 ) readdata [31:0] $end
$var reg 1 * reset $end
$var reg 1 + waitrequest $end
$scope module dut $end
$var wire 1 , PC_write_condcomb $end
$var wire 1 ( clk $end
$var wire 32 - readdata [31:0] $end
$var wire 1 * reset $end
$var wire 1 + waitrequest $end
$var wire 32 . writedata [31:0] $end
$var wire 1 " write $end
$var wire 5 / shift [4:0] $end
$var wire 5 0 rt [4:0] $end
$var wire 5 1 rs [4:0] $end
$var wire 32 2 register_v0 [31:0] $end
$var wire 1 3 reg_write $end
$var wire 2 4 reg_dest [1:0] $end
$var wire 1 5 reg_data_sel $end
$var wire 5 6 reg_data_dest [4:0] $end
$var wire 32 7 reg_data [31:0] $end
$var wire 32 8 reg_B [31:0] $end
$var wire 32 9 reg_A [31:0] $end
$var wire 1 $ read $end
$var wire 5 : rd [4:0] $end
$var wire 6 ; op [5:0] $end
$var wire 32 < mem_paddr [31:0] $end
$var wire 32 = mem_data [31:0] $end
$var wire 26 > mem_address [25:0] $end
$var wire 1 ? lo_sel $end
$var wire 32 @ lo_out [31:0] $end
$var wire 32 A lo_in [31:0] $end
$var wire 1 B lo_en $end
$var wire 32 C jumpaddress [31:0] $end
$var wire 2 D instr_type [1:0] $end
$var wire 32 E i_ex_sl [31:0] $end
$var wire 32 F i_ex [31:0] $end
$var wire 16 G i [15:0] $end
$var wire 1 H hi_sel $end
$var wire 32 I hi_out [31:0] $end
$var wire 32 J hi_in [31:0] $end
$var wire 1 K hi_en $end
$var wire 6 L func [5:0] $end
$var wire 1 M extend $end
$var wire 32 N data_2 [31:0] $end
$var wire 32 O data_1 [31:0] $end
$var wire 4 P byteenable [3:0] $end
$var wire 32 Q address [31:0] $end
$var wire 1 ' active $end
$var wire 1 R PC_write_cond $end
$var wire 1 S PC_write $end
$var wire 2 T PC_src [1:0] $end
$var wire 32 U PC_out [31:0] $end
$var wire 32 V PC_in [31:0] $end
$var wire 1 W IoD $end
$var wire 1 X IR_write $end
$var wire 1 Y IR_sel $end
$var wire 32 Z ALUout_delay [31:0] $end
$var wire 32 [ ALUout [31:0] $end
$var wire 5 \ ALUop [4:0] $end
$var wire 32 ] ALUlo [31:0] $end
$var wire 32 ^ ALUhi [31:0] $end
$var wire 2 _ ALU_srcB [1:0] $end
$var wire 1 ` ALU_srcA $end
$var wire 32 a ALU_inB [31:0] $end
$var wire 32 b ALU_inA [31:0] $end
$scope module A $end
$var wire 1 ( clk $end
$var wire 1 * reset $end
$var wire 32 c data_in [31:0] $end
$var reg 32 d data_out [31:0] $end
$var reg 32 e reg_val [31:0] $end
$upscope $end
$scope module ALUo $end
$var wire 1 ( clk $end
$var wire 1 * reset $end
$var wire 32 f data_in [31:0] $end
$var reg 32 g data_out [31:0] $end
$var reg 32 h reg_val [31:0] $end
$upscope $end
$scope module B $end
$var wire 1 ( clk $end
$var wire 1 * reset $end
$var wire 32 i data_in [31:0] $end
$var reg 32 j data_out [31:0] $end
$var reg 32 k reg_val [31:0] $end
$upscope $end
$scope module j_adrs $end
$var wire 32 l pc_val [31:0] $end
$var wire 26 m mem_address [25:0] $end
$var wire 32 n jump_address [31:0] $end
$upscope $end
$scope module mips_IoD $end
$var wire 1 W select $end
$var wire 32 o input_1 [31:0] $end
$var wire 32 p input_0 [31:0] $end
$var reg 32 q out [31:0] $end
$upscope $end
$scope module mips_alu $end
$var wire 32 r rs [31:0] $end
$var wire 32 s rt [31:0] $end
$var wire 5 t tmp_shift [4:0] $end
$var wire 5 u shift [4:0] $end
$var wire 32 v ALU_lo [31:0] $end
$var wire 32 w ALU_hi [31:0] $end
$var wire 5 x ALU_ctrl [4:0] $end
$var reg 32 y ALU_out [31:0] $end
$var reg 64 z tmp [63:0] $end
$upscope $end
$scope module mips_aluA_mux $end
$var wire 32 { input_1 [31:0] $end
$var wire 1 ` select $end
$var wire 32 | input_0 [31:0] $end
$var reg 32 } out [31:0] $end
$upscope $end
$scope module mips_aluB_mux $end
$var wire 32 ~ input_0 [31:0] $end
$var wire 32 !" input_1 [31:0] $end
$var wire 2 "" select [1:0] $end
$var wire 32 #" input_3 [31:0] $end
$var wire 32 $" input_2 [31:0] $end
$var reg 32 %" out [31:0] $end
$upscope $end
$scope module mips_control $end
$var wire 1 ( clk $end
$var wire 1 * reset $end
$var wire 1 + waitrequest $end
$var wire 5 &" rt [4:0] $end
$var wire 6 '" op [5:0] $end
$var wire 6 (" func [5:0] $end
$var wire 32 )" address [31:0] $end
$var reg 1 ` ALU_srcA $end
$var reg 2 *" ALU_srcB [1:0] $end
$var reg 5 +" ALUop [4:0] $end
$var reg 1 Y IR_sel $end
$var reg 1 X IR_write $end
$var reg 1 W IoD $end
$var reg 2 ," PC_src [1:0] $end
$var reg 1 S PC_write $end
$var reg 1 R PC_write_cond $end
$var reg 1 ' active $end
$var reg 1 M extend $end
$var reg 1 K hi_en $end
$var reg 1 H hi_sel $end
$var reg 2 -" instr_type [1:0] $end
$var reg 1 B lo_en $end
$var reg 1 ? lo_sel $end
$var reg 1 $ mem_read $end
$var reg 1 " mem_write $end
$var reg 1 5 reg_data_sel $end
$var reg 2 ." reg_dest [1:0] $end
$var reg 1 3 reg_write $end
$var reg 3 /" state [2:0] $end
$upscope $end
$scope module mips_extend $end
$var wire 1 M zero_sign $end
$var wire 1 0" tmp $end
$var wire 16 1" in [15:0] $end
$var reg 32 2" out [31:0] $end
$upscope $end
$scope module mips_hi_reg $end
$var wire 1 ( clk $end
$var wire 1 K enable $end
$var wire 1 * reset $end
$var wire 32 3" data_in [31:0] $end
$var reg 32 4" data_out [31:0] $end
$var reg 32 5" reg_val [31:0] $end
$upscope $end
$scope module mips_hi_reg_mux $end
$var wire 32 6" input_0 [31:0] $end
$var wire 32 7" input_1 [31:0] $end
$var wire 1 H select $end
$var reg 32 8" out [31:0] $end
$upscope $end
$scope module mips_ir $end
$var wire 1 X IRWrite $end
$var wire 1 Y IR_sel $end
$var wire 1 ( clk $end
$var wire 32 9" mem_input [31:0] $end
$var wire 1 * reset $end
$var reg 6 :" func [5:0] $end
$var reg 16 ;" i [15:0] $end
$var reg 32 <" instr [31:0] $end
$var reg 6 =" m_func [5:0] $end
$var reg 16 >" m_i [15:0] $end
$var reg 26 ?" m_mem_address [25:0] $end
$var reg 6 @" m_op [5:0] $end
$var reg 5 A" m_rd [4:0] $end
$var reg 5 B" m_rs [4:0] $end
$var reg 5 C" m_rt [4:0] $end
$var reg 5 D" m_shift [4:0] $end
$var reg 26 E" mem_address [25:0] $end
$var reg 6 F" op [5:0] $end
$var reg 5 G" rd [4:0] $end
$var reg 5 H" rs [4:0] $end
$var reg 5 I" rt [4:0] $end
$var reg 5 J" shift [4:0] $end
$var reg 6 K" t_func [5:0] $end
$var reg 16 L" t_i [15:0] $end
$var reg 26 M" t_mem_address [25:0] $end
$var reg 6 N" t_op [5:0] $end
$var reg 5 O" t_rd [4:0] $end
$var reg 5 P" t_rs [4:0] $end
$var reg 5 Q" t_rt [4:0] $end
$var reg 5 R" t_shift [4:0] $end
$upscope $end
$scope module mips_lo_reg $end
$var wire 1 ( clk $end
$var wire 1 B enable $end
$var wire 1 * reset $end
$var wire 32 S" data_in [31:0] $end
$var reg 32 T" data_out [31:0] $end
$var reg 32 U" reg_val [31:0] $end
$upscope $end
$scope module mips_lo_reg_mux $end
$var wire 32 V" input_0 [31:0] $end
$var wire 32 W" input_1 [31:0] $end
$var wire 1 ? select $end
$var reg 32 X" out [31:0] $end
$upscope $end
$scope module mips_mem_dec $end
$var wire 1 ( clk $end
$var wire 32 Y" data_in [31:0] $end
$var wire 6 Z" op [5:0] $end
$var wire 1 * reset $end
$var wire 32 [" rt [31:0] $end
$var wire 8 \" rt_byte3 [7:0] $end
$var wire 8 ]" rt_byte2 [7:0] $end
$var wire 8 ^" rt_byte1 [7:0] $end
$var wire 8 _" rt_byte0 [7:0] $end
$var wire 4 `" byteenable [3:0] $end
$var wire 1 a" byte3_msb $end
$var wire 8 b" byte3 [7:0] $end
$var wire 1 c" byte2_msb $end
$var wire 8 d" byte2 [7:0] $end
$var wire 1 e" byte1_msb $end
$var wire 8 f" byte1 [7:0] $end
$var wire 1 g" byte0_msb $end
$var wire 8 h" byte0 [7:0] $end
$var reg 4 i" be_signal [3:0] $end
$var reg 32 j" data_out [31:0] $end
$upscope $end
$scope module mips_out $end
$var wire 32 k" cpu_out [31:0] $end
$var wire 2 l" instr_type [1:0] $end
$var wire 6 m" op [5:0] $end
$var wire 32 n" mem_addr [31:0] $end
$var wire 4 o" byteenable [3:0] $end
$var wire 2 p" byte_idx [1:0] $end
$var reg 1 q" byte0 $end
$var reg 1 r" byte1 $end
$var reg 1 s" byte2 $end
$var reg 1 t" byte3 $end
$upscope $end
$scope module mips_pc $end
$var wire 1 ( clk $end
$var wire 2 u" instr_type [1:0] $end
$var wire 1 S pc_ctrl $end
$var wire 1 , pc_write_cond $end
$var wire 1 * reset $end
$var wire 1 + waitrequest $end
$var wire 32 v" nxt_pc_val [31:0] $end
$var reg 32 w" BoJ [31:0] $end
$var reg 1 x" BoJ_flag $end
$var reg 3 y" counter [2:0] $end
$var reg 32 z" cur_pc_val [31:0] $end
$var reg 32 {" pc_val [31:0] $end
$upscope $end
$scope module mips_pc_mux $end
$var wire 32 |" input_0 [31:0] $end
$var wire 32 }" input_1 [31:0] $end
$var wire 32 ~" input_2 [31:0] $end
$var wire 32 !# input_3 [31:0] $end
$var wire 2 "# select [1:0] $end
$var reg 32 ## out [31:0] $end
$upscope $end
$scope module mips_reg_data_in $end
$var wire 32 $# input_0 [31:0] $end
$var wire 32 %# input_1 [31:0] $end
$var wire 1 5 select $end
$var reg 32 &# out [31:0] $end
$upscope $end
$scope module mips_reg_write_adr_mux $end
$var wire 5 '# input_0 [4:0] $end
$var wire 5 (# input_1 [4:0] $end
$var wire 5 )# input_2 [4:0] $end
$var wire 2 *# select [1:0] $end
$var reg 5 +# out [4:0] $end
$upscope $end
$scope module mips_register $end
$var wire 1 3 Regwrite $end
$var wire 1 ( clk $end
$var wire 5 ,# read_register_1 [4:0] $end
$var wire 5 -# read_register_2 [4:0] $end
$var wire 32 .# register_v0 [31:0] $end
$var wire 1 * reset $end
$var wire 32 /# write_data [31:0] $end
$var wire 5 0# write_register [4:0] $end
$var reg 32 1# a0 [31:0] $end
$var reg 32 2# a1 [31:0] $end
$var reg 32 3# a2 [31:0] $end
$var reg 32 4# a3 [31:0] $end
$var reg 32 5# at [31:0] $end
$var reg 32 6# fp [31:0] $end
$var reg 32 7# gp [31:0] $end
$var reg 32 8# k0 [31:0] $end
$var reg 32 9# k1 [31:0] $end
$var reg 32 :# ra [31:0] $end
$var reg 32 ;# read_data_1 [31:0] $end
$var reg 32 <# read_data_2 [31:0] $end
$var reg 32 =# s0 [31:0] $end
$var reg 32 ># s1 [31:0] $end
$var reg 32 ?# s2 [31:0] $end
$var reg 32 @# s3 [31:0] $end
$var reg 32 A# s4 [31:0] $end
$var reg 32 B# s5 [31:0] $end
$var reg 32 C# s6 [31:0] $end
$var reg 32 D# s7 [31:0] $end
$var reg 32 E# sp [31:0] $end
$var reg 32 F# t0 [31:0] $end
$var reg 32 G# t1 [31:0] $end
$var reg 32 H# t2 [31:0] $end
$var reg 32 I# t3 [31:0] $end
$var reg 32 J# t4 [31:0] $end
$var reg 32 K# t5 [31:0] $end
$var reg 32 L# t6 [31:0] $end
$var reg 32 M# t7 [31:0] $end
$var reg 32 N# t8 [31:0] $end
$var reg 32 O# t9 [31:0] $end
$var reg 32 P# v0 [31:0] $end
$var reg 32 Q# v1 [31:0] $end
$var reg 32 R# zero [31:0] $end
$upscope $end
$scope module mips_shift2 $end
$var wire 32 S# in [31:0] $end
$var wire 32 T# out [31:0] $end
$upscope $end
$scope module mips_store $end
$var wire 32 U# data_in [31:0] $end
$var wire 6 V# op [5:0] $end
$var reg 8 W# byte3 [7:0] $end
$var reg 32 X# data_out [31:0] $end
$var reg 16 Y# halfword [15:0] $end
$upscope $end
$upscope $end
$upscope $end
$enddefinitions $end
#0
$dumpvars
bx Y#
bx X#
bx W#
b0 V#
b0 U#
b0 T#
b0 S#
bx R#
bx Q#
bx P#
bx O#
bx N#
bx M#
bx L#
bx K#
bx J#
bx I#
bx H#
bx G#
bx F#
bx E#
bx D#
bx C#
bx B#
bx A#
bx @#
bx ?#
bx >#
bx =#
b0 <#
b0 ;#
bx :#
bx 9#
bx 8#
bx 7#
bx 6#
bx 5#
bx 4#
bx 3#
bx 2#
bx 1#
b0 0#
b0 /#
bx .#
b0 -#
b0 ,#
b0 +#
b0 *#
b11111 )#
b0 (#
b0 '#
b0 &#
bx %#
b0 $#
b0 ##
b1 "#
b0 !#
b10110000000000000000000000000000 ~"
b0 }"
b0 |"
bx {"
b10111111110000000000000000000000 z"
bx y"
xx"
bx w"
b0 v"
b0 u"
1t"
1s"
1r"
1q"
b0 p"
b1111 o"
b10111111110000000000000000000000 n"
b0 m"
b0 l"
b10111111110000000000000000000000 k"
bx j"
bx i"
bx h"
xg"
bx f"
xe"
bx d"
xc"
bx b"
xa"
b1111 `"
b0 _"
b0 ^"
b0 ]"
b0 \"
b0 ["
b0 Z"
bx Y"
bx X"
b0 W"
bx V"
bx U"
b0 T"
bx S"
bx R"
bx Q"
bx P"
bx O"
bx N"
bx M"
bx L"
bx K"
b0 J"
b0 I"
b0 H"
b0 G"
b0 F"
b0 E"
bx D"
bx C"
bx B"
bx A"
bx @"
bx ?"
bx >"
bx ="
bx <"
b0 ;"
b0 :"
bx 9"
bx 8"
b0 7"
bx 6"
bx 5"
b0 4"
bx 3"
b0 2"
b0 1"
00"
b0 /"
b0 ."
b0 -"
b1 ,"
b0 +"
b1 *"
b10111111110000000000000000000000 )"
b0 ("
b0 '"
b0 &"
b100 %"
b0 $"
b0 #"
b1 ""
b100 !"
b0 ~
b10111111110000000000000000000000 }
b10111111110000000000000000000000 |
b0 {
bx z
b0 y
b0 x
bx w
bx v
b0 u
b0 t
b0 s
b0 r
b10111111110000000000000000000000 q
b10111111110000000000000000000000 p
b0 o
b10110000000000000000000000000000 n
b0 m
b10111111110000000000000000000000 l
b0 k
b0 j
b0 i
b0 h
b0 g
b0 f
b0 e
b0 d
b0 c
b10111111110000000000000000000000 b
b100 a
0`
b1 _
bx ^
bx ]
b0 \
b0 [
b0 Z
0Y
1X
0W
b0 V
b10111111110000000000000000000000 U
b1 T
xS
0R
b10111111110000000000000000000000 Q
b1111 P
b0 O
b0 N
0M
b0 L
0K
bx J
b0 I
0H
b0 G
b0 F
b0 E
b0 D
b10110000000000000000000000000000 C
0B
bx A
b0 @
0?
b0 >
bx =
b10111111110000000000000000000000 <
b0 ;
b0 :
b0 9
b0 8
b0 7
b0 6
05
b0 4
03
bx 2
b0 1
b0 0
b0 /
bx .
bx -
0,
x+
1*
bx )
0(
1'
b10111111110000000000000000000000 &
b1111 %
1$
bx #
0"
bx !
$end
#10
b0 <"
b0 :#
b0 6#
b0 E#
b0 7#
b0 9#
b0 8#
b0 O#
b0 N#
b0 D#
b0 C#
b0 B#
b0 A#
b0 @#
b0 ?#
b0 >#
b0 =#
b0 M#
b0 L#
b0 K#
b0 J#
b0 I#
b0 H#
b0 G#
b0 F#
b0 4#
b0 3#
b0 2#
b0 1#
b0 Q#
b0 #
b0 2
b0 .#
b0 P#
b0 5#
b0 R#
b0 i"
b0 U"
b0 5"
b0 y"
b0 w"
b10111111110000000000000000000000 {"
1(
#20
b0xxxxxxxxxxxxxxxx00 E
b0xxxxxxxxxxxxxxxx00 #"
b0xxxxxxxxxxxxxxxx00 T#
x0"
b0xxxxxxxxxxxxxxxx F
b0xxxxxxxxxxxxxxxx $"
b0xxxxxxxxxxxxxxxx 2"
b0xxxxxxxxxxxxxxxx S#
bx 6
bx +#
bx 0#
b1011xxxxxxxxxxxxxxxxxxxxxxxxxx00 C
b1011xxxxxxxxxxxxxxxxxxxxxxxxxx00 n
b1011xxxxxxxxxxxxxxxxxxxxxxxxxx00 ~"
bx >
bx m
bx E"
bx G
bx 1"
bx ;"
bx L
bx ("
bx :"
bx /
bx u
bx J"
bx 0
bx &"
bx I"
bx '#
bx -#
bx :
bx G"
bx (#
bx 1
bx H"
bx ,#
bx ;
bx '"
bx F"
bx Z"
bx m"
bx V#
0(
0*
#30
b1111 i"
bx <"
1(
#40
0(
#50
1(
#60
0(
#70
1(
#80
0(
#90
1(
#100
0(
#110
1(
#120
0(
#130
1(
#140
0(
#150
1(
